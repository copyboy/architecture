## 二、语法糖及其实现

https://blog.csdn.net/u013452337/article/details/90171881

### 1）switch 支持 String 与枚举

> [菜鸟教程switch-case讲解](https://www.runoob.com/java/java-switch-case.html)

switch case 语句有如下规则：

- switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。

  ```text
  纠正：变量类型可以时char,byte,short,int 以及对应的包装类型Character/Byte/Short/Integer，还有String类型以及枚举类型
  ```

  ![image-20200623220750179](http://img.zhangqingdong.cn/image-20200623220750179.png)

- switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。

- case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。

  ```text
  纠正：当switch语句中的值为数值类型时，case值可以为范围比它小的数值类型，例如，如果是switch(int) ,case的值可以为任意的char,byte,short类型的值。
  ```

- 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。

- 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。

- switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。

> 总结

Switch-case 支持三种入参类型：

```java
package com.deepj.architecture.chapter01;

/**
 * Java基础；语法糖及其实现机制
 *
 * @author qingdong.zhang
 * @version 1.0
 * @since 2020-6-22-22:05
 */
public class Chapter0121 {
	// 3）字符串类型
    public static String switchStrCase(String name) {

        String personDeclaration;
        switch (name) {
            case "job":
                personDeclaration = "I'm job, I'm a student.";
                break;
            case "mic":
                personDeclaration = "I'm mic, I work for APPLE.";
                break;
            case "rues":
                personDeclaration = "I'm rues, I was a football player.";
                break;
            default:
                personDeclaration = "Hi, welcome to deepj's tutorial blog. ";
        }
        return personDeclaration;
    }
	// 2）枚举类型
    public static String switchEnumCase(LangEnum lang) {

        String lanLabel;
        switch (lang) {
            case JAVA:
                lanLabel = "Java is simple.";
                break;
            case PHP:
                lanLabel = "PHP is the best.";
                break;
            case PYTHON:
                lanLabel = "Life is short you need python.";
                break;
            default:
                lanLabel = "Talk is cheap, show me the code.";
        }
        return lanLabel;
    }

    // 1）数值类型
    public static String switchIntCase(int x) {
        String caseWhen;
        switch (x) {
            case 'A':
                caseWhen = "char case in int switch.";
                break;
            case (byte) 127:
                caseWhen = "byte case in int switch.";
                break;
            case (short) 32767:
                caseWhen = "short case in int switch.";
                break;
            case 0x7fffffff:
                caseWhen = "int case in int switch.";
                break;
            default:
                caseWhen = "deepj's. int case default.";
        }
        return caseWhen;
    }
    public static void main(String[] args) {

        System.out.println(LangEnum.JAVA.ordinal());
        System.out.println(switchEnumCase(LangEnum.JAVA));
        System.out.println(Arrays.toString(LangEnum.values()));
    }
}

enum LangEnum {

    JAVA,
    PYTHON,
    CPP,
    GO,
    PERL,
    PHP;
}

```

反编译后代码

```java
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   Chapter0121.java

package com.deepj.architecture.chapter01;

import com.deepj.architecture.common.LangEnum;
import java.io.PrintStream;
import java.util.Arrays;

public class Chapter0121
{

    public Chapter0121()
    {
    }

    public static String switchStrCase(String name)
    {
        String s = name;
        byte byte0 = -1;
        switch(s.hashCode())
        {
        case 105405: 
            if(s.equals("job"))
                byte0 = 0;
            break;

        case 108103: 
            if(s.equals("mic"))
                byte0 = 1;
            break;

        case 3511857: 
            if(s.equals("rues"))
                byte0 = 2;
            break;
        }
        String personDeclaration;
        switch(byte0)
        {
        case 0: // '\0'
            personDeclaration = "I'm job, I'm a student.";
            break;

        case 1: // '\001'
            personDeclaration = "I'm mic, I work for APPLE.";
            break;

        case 2: // '\002'
            personDeclaration = "I'm rues, I was a football player.";
            break;

        default:
            personDeclaration = "Hi, welcome to deepj's tutorial blog. ";
            break;
        }
        return personDeclaration;
    }

    public static String switchEnumCase(LangEnum lang)
    {
        static class _cls1
        {

            static final int $SwitchMap$com$deepj$architecture$common$LangEnum[];

            static 
            {
                $SwitchMap$com$deepj$architecture$common$LangEnum = new int[LangEnum.values().length];
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.JAVA.ordinal()] = 1;
                }
                catch(NoSuchFieldError nosuchfielderror) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PHP.ordinal()] = 2;
                }
                catch(NoSuchFieldError nosuchfielderror1) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PYTHON.ordinal()] = 3;
                }
                catch(NoSuchFieldError nosuchfielderror2) { }
            }
        }

        String lanLabel;
        switch(_cls1..SwitchMap.com.deepj.architecture.common.LangEnum[lang.ordinal()])
        {
        case 1: // '\001'
            lanLabel = "Java is simple.";
            break;

        case 2: // '\002'
            lanLabel = "PHP is the best.";
            break;

        case 3: // '\003'
            lanLabel = "Life is short you need python.";
            break;

        default:
            lanLabel = "Talk is cheap, show me the code.";
            break;
        }
        return lanLabel;
    }

    public static String switchIntCase(int x)
    {
        String caseWhen;
        switch(x)
        {
        case 65: // 'A'
            caseWhen = "char case in int switch.";
            break;

        case 127: // '\177'
            caseWhen = "byte case in int switch.";
            break;

        case 32767: 
            caseWhen = "short case in int switch.";
            break;

        case 2147483647: 
            caseWhen = "int case in int switch.";
            break;

        default:
            caseWhen = "deepj's. int case default.";
            break;
        }
        return caseWhen;
    }
    public static void main(String[] args) {
        System.out.println(LangEnum.JAVA.ordinal());
        System.out.println(switchEnumCase(LangEnum.JAVA));
        System.out.println(Arrays.toString(LangEnum.values()));
    }
}

```



#### Ⅰ）数值类型

数值类型能够看出最底层都转化为int类型的数值，进行比对，这样也就可以解释switch(int) case中的值可以是byte,short

#### Ⅱ）字符串类型

字符串类型可以看出是进行了两次switch比较，

第一层先使用string类型的hashcode作为switch(int) 值，case使用hashcode值，如果比较相等，再使用string类型的equals确定值相等

第二层使用第一层比较的结果来作为switch的入参。

#### Ⅲ）枚举类型

```java
static class _cls1
        {

            static final int $SwitchMap$com$deepj$architecture$common$LangEnum[];

            static 
            {
                $SwitchMap$com$deepj$architecture$common$LangEnum = new int[LangEnum.values().length];
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.JAVA.ordinal()] = 1;
                }
                catch(NoSuchFieldError nosuchfielderror) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PHP.ordinal()] = 2;
                }
                catch(NoSuchFieldError nosuchfielderror1) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PYTHON.ordinal()] = 3;
                }
                catch(NoSuchFieldError nosuchfielderror2) { }
            }
        }
```

枚举类型比较复杂，先是使用了一个静态内部类，在内部维护了数组对象，，该数组对象是枚举值的序数映射。

可以把$SwitchMap$com$deepj$architecture$common$LangEnum 变量名称 替换为 enumArr ，就会简明许多。

```java
尝试破坏该数组对象：使其返回错误对象，比如我输入Java，它却告诉我PHP对应的输出，
主要思路：只要破坏了这个数组对象的值，就会可能产生问题

1） LangEnum 是两个文件，编译和调用的是不一样的类对象， 
思路错误：两个文件，在调用时就会提示需要使用编译的那个类对象

2） LangEnum 是一个类，先编译一次 LangEnum.java 和 Chapter0121.java ，Chapter0121中的main方法会使用LangEnum.JAVA.origin值，之后改动LangEnum.java 中JAVA的顺序，再单独编译LangEnum.java 
思路错误：静态内部类每次在重启时后，在调用时，会重新启动，所以每次重新进行main方法的运行，都相当于重新加载了LangEnum文件
System.out.println(LangEnum.JAVA.ordinal());
System.out.println(switchEnumCase(LangEnum.JAVA));
System.out.println(Arrays.toString(LangEnum.values()));

3） 在2）的基础上，改造一下，仅调用main一次，然后静态内部类也就初始化一次，然后我再修改LangEnum后，把该文件进行重新编译，
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String s = sc.nextLine();
            System.out.println(LangEnum.JAVA.ordinal());
            System.out.println(switchEnumCase(LangEnum.JAVA));
            System.out.println(Arrays.toString(LangEnum.values()));
        }
    }
出现问题：1:14	Hot Swap failed.
		Chapter0121: schema change not implemented
		Chapter0121: Operation not supported by VM
		每次在不重启重新编译LangEnum的时候，告知不能单独编译这样一个文件，
		查找原因说是jvm hotswap的限制，解释说它只允许修改方法体，不能有方法或属性的添加和删除。
		我们这里修改了LangEnum的顺序，其实也就对枚举类中public static final 修饰的属性进行更改了，所以虚拟机不允许我们进行修改了，
        
综上结论：
	枚举类的switch case 是安全的，不会出现多文件,或者认为修改枚举然后未编译代码，导致出现的逻辑错误问题。
```





### 2）泛型

[泛型就这么简单](https://segmentfault.com/a/1190000014120746)

#### Ⅰ）泛型做了什么

**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

#### Ⅱ）为什么需要泛型

> 设想没有泛型会发生什么？

```java
class Chapter01_2_2_Test {

    @Test
    public void generic_without() {

        Map map = new HashMap();
        map.put("cat1", new Cat("Cat1"));
        map.put("cat2", new Cat("Cat2"));
        map.put("cat3", new Cat("Cat3"));
        map.put("cat4", new Dog("Dog1"));

        for (int i = 0; i < map.size(); i++) {
            Cat cat = (Cat) map.get("cat" + (i + 1));
            System.out.println(cat.getName());
        }
    }

}
```

在对象取用时，需要强行转换为需要的对象类型，如果存在其他类型，会导致出现`ClassCastException`

```java
for (int i = 0; i < map.size(); i++) {
    Object o = map.get("cat" + (i + 1));
    if (o instanceof Cat) {
        Cat cat = (Cat) o;
        System.out.println(cat.getName());
    } else if (o instanceof Dog) {
        Dog dog = (Dog) o;
        System.out.println("忽略DOG的参数"+dog.getName());
    }
}
```

可以在取用对象值的时候， 先经过 instanceof 判断实际类型，再进行强制转换，这样可以避免运行时代码出现错误。

但是这样每次新增一种类型之后，调用的地方就需要进行适配处理，拓展性太差。

#### Ⅲ）使用泛型的好处

- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
- 可读性和稳定性【在编写集合的时候，就限定了类型】

#### Ⅳ）泛型使用

##### 4.1 泛型类

```java
// 常用于定义通用报文请求/返回，把请求/返回特有的数据放在data中传输，通用属性提取出来使用
@Data
class ApiResult<T> {

    private String code;
    private String msg;
    private T data;
}
```

##### 4.2 泛型方法

```java
public class BaseRequest {
    private String seqNo;
}
public class BaseResponse {
    private String code;
    private String msg;
}

// 泛型方法常用的地点：
// 1. 不明确当前需要传递什么值，但有一种统一的处理逻辑， 使用<T> 
// 2. 需要了解T内部的一些公用字段，需要限定T的上界，用于逻辑处理
class restClient {
    public <T> void send(T req) {
        System.out.println(req.toString());
    }
    public <T extends BaseRequest, R extends BaseResponse> R sendReq(T req, Class<R> clz) {
        System.out.println(req.getSeqNo());
        // restTemplate 请求获取结果，可以直接与restTemplate结合取得对象结果
        // 或者通过获取string 对象,经过Json转化得到实体对象
        R response = null;
//        HttpEntity<String> entity = new HttpEntity<>(req);
//        response = restTemplate.postForObject(url, entity, clz);
        return response;
    }
}
```

##### 4.3 泛型类派生

```java
interface Api<T>{
    Api<T> success(T t);
    Api<T> error(T t);
}
// 子类明确泛型类的类型参数变量
class CommonApi implements Api<String>{

    String code;
    public CommonApi(String code){
        this.code = code;
    }
    @Override
    public Api<String> success(String s) {
        return new CommonApi("SUCCESS="+s);

    }
    @Override
    public Api<String> error(String s) {
        return new CommonApi("ERROR="+s);
    }
}
// 子类不明确泛型类的类型参数变量，需要在使用时明确泛型类的具体对象
class AbstractApi<T> implements Api<T> {

    @Override
    public Api<T> success(T t) {
        return null;
    }

    @Override
    public Api<T> error(T t) {
        return null;
    }
}
```

##### 4.4 泛型通配符

```java
class CommonCharacter{
    // Raw use of parameterized class 'List'  不够优雅
    public void test0(List list){
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    // 使用通配符来适配所有的List参数对象，默认? 继承自 Object
    public void test1(List<?> list){
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    // 当List内容上限已知时，可以限定该上限
    public void test2(List<? extends Number> list) {
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i).intValue());
        }
    }
    // 有上限就会有下限，下限使用场景：<? super Type> 传递进来的只能是Type或Type的父类
    // 使用场景较少，暂时能想到的只有 Comparator ，当某个对象需要组合其他对象的功能时，可能需要实现
    public void test3(Comparator<? super TreeSet<?>> comparator) {
    }
}

```

```shell
在泛型的上限和下限中有一个原则：PECS(Producer Extends Consumer Super)

带有子类限定的可以从泛型读取【也就是--->(? extend T)】-------->Producer Extends
带有超类限定的可以从泛型写入【也就是--->(? super T)】-------->Consumer Super

```



#### V) 泛型擦除

泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。

也就是在实际的字节码文件中，泛型信息已经全部被擦除了。

进行反编译验证：`jad -sjava CommonCharacter.class`

```java
class CommonCharacter {

    CommonCharacter() {
    }
    public void test0(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));
    }
    public void test1(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));
    }
    public void test2(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(((Number)list.get(i)).intValue());
    }
    public void test3(Comparator comparator1) {
    }
}
```

可以明显看出泛型参数类型已经被去除掉。



### 3）自动拆装箱

#### Ⅰ）什么是自动拆装箱

| 8大基本类型 | 包装类型  | 缓存值     | 字节长度 | 缓存重定义                          |
| ----------- | --------- | ---------- | -------- | ----------------------------------- |
| byte        | Byte      | [-128,127] | 1        |                                     |
| char        | Character | [0,127]    | 2        |                                     |
| short       | Short     | [-128,127] | 2        |                                     |
| int         | Integer   | [-128,127] | 4        | java.lang.Integer.IntegerCache.high |
| long        | Long      | [-128,127] | 8        |                                     |
| float       | Float     | 无         | 4        |                                     |
| double      | Double    | 无         | 8        |                                     |
| boolean     | Boolean   | 无         | 1        |                                     |

> 概念解析

Java 系统内由 基本类型转换为包装类型，称为装箱，相反由包装类转化为基本类型的称为拆箱，因为这些动作不需要开发人员参与，所以叫做自动拆装箱。

> 使用场景

```java
// 源码
public static void main(String[] args) {
    Integer i = 10;
    int j = i;
}
// 反编译代码 jad -sjava Chapter01_2_3.class
public static void main(String args[]){
    Integer i = Integer.valueOf(10);
    int j = i.intValue();
}
```

`Integer i = 10;`

当把基本类型值直接赋值给包装类型时，这个过程就会产生自动装箱

`int j = i;`

当把包装类型i直接赋值给基本类型时，会产生自动拆箱的动作。



其他基本类型与包装类型的自动拆装箱与此类似。

![image-20200701115802363](http://img.zhangqingdong.cn/image-20200701115802363.png)

Byte/Short/Integer/Long/Float/Double 都继承自`Number` ,所以都可以转换成这六类对象的基本类型。

![image-20200701143132503](http://img.zhangqingdong.cn/image-20200701143132503.png)

#### Ⅱ） 有什么用

1. 可以直接给包装类型赋值，不需要显示转换
2. 包装类与基本类型可以混用，无需进行强制转换

#### Ⅲ）踩坑指南

> 包装类缓存

```java
private static void testEqual() {
    Integer a = 127;
    Integer b = 127;
    System.out.println("a == b => " + (a == b));

    Integer x = 128;
    Integer y = 128;
    System.out.println("x == y => " + (x == y));
}

// ======== output =========
// a == b => true
// x == y => false
```

如果不知道自动装箱机制，这里就会感觉莫名其妙，明明一样的处理，为什么，一个127 是true，128就是false。

但经过上面的装箱机制，我们知道 `Integer x = 128;` 转化成了 `Integer x = Integer.valueOf(128);`

现在看下`Integer.valueOf() `方法源码：

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

这里经过了一个比较， 如果 `int i `的值在`IntegerCache.low`和`IntegerCache.high`的区间内，就拿`IntegerCache.cache `中的缓存来赋值。

这个缓存的值在 **什么是自动拆装箱** 表中已经展示了出来，区间为[-128,127] ，且这个值可以配置。配置项为`java.lang.Integer.IntegerCache.high`



> 空指针

```java
private static void testNullPoint(){
    Integer a = 10;
    // ==== 经过各种业务操作 start ====
    a = null;
    // ==== 经过各种业务操作 end ====
    int b = a;
}

// com.deepj.architecture.chapter01.Chapter01_2_3
// Exception in thread "main" java.lang.NullPointerException
// 		at com.deepj.architecture.chapter01.Chapter01_2_3.testNullPoint(Chapter01_2_3.java:48)
// 		at com.deepj.architecture.chapter01.Chapter01_2_3.main(Chapter01_2_3.java:15)
```

同理，在`int b = a;` 该行抛出一个空指针，如果不知道自动拆箱机制，也会导致开发人员一脸生无可恋。

此时知道有拆箱机制，看下具体原因 `int b = a.intValue();`此时`a`为null， 也就显而易见报了空指针



> 基本类型与包装类型的混合操作

```java
// 源码
private static void testEquals() {
    int a = 128;
    Integer b = 128;
    System.out.println("1>>> " + (a == b));
    System.out.println("2>>> " + b.equals(a));

    System.out.println("3>>> " + b.equals(127 + 1));
    System.out.println("4>>> " + b.equals(127L + 1));
}
// 反编译 jad -sjava Chapter01_2_3.class
private static void testEquals(){
    int a = 128;
    Integer b = Integer.valueOf(128);
    System.out.println((new StringBuilder()).append("1>>> ")
                       .append(a == b.intValue()).toString());
    System.out.println((new StringBuilder()).append("2>>> ")
                       .append(b.equals(Integer.valueOf(a))).toString());
    System.out.println((new StringBuilder()).append("3>>> ")
                       .append(b.equals(Integer.valueOf(128))).toString());
    System.out.println((new StringBuilder()).append("4>>> ")
                       .append(b.equals(Long.valueOf(128L))).toString());
}

// =========== output =================
// 1>>> true
// 2>>> true
// 3>>> true
// 4>>> false
```

+ **当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。**
+ **当基础数据类型与包装类型进行 equals 比较时，所传入的参数类型是原始数据类型时，会自动对其装箱，** 且相关equals方法被重写为 `obj instanceof Integer && value == ((Integer)obj).intValue()`



> 无意识装箱性能消耗

```java
private static void testPerformance() {
    long time1 = System.currentTimeMillis();
    long sum = 0L;
    for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
        sum += i;
    }
    System.out.println(sum);
    System.out.println(System.currentTimeMillis() - time1);

    System.out.println("==========================================");

    long time2 = System.currentTimeMillis();
    Long sum1 = 0L;
    for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
        sum1 += i;
    }
    System.out.println(sum);
    System.out.println(System.currentTimeMillis() - time2);
}

// =================== output =======================

// 576460750692810753
// 288
// ==========================================
// 576460750692810753
// 3065

```

仅仅是定义 `long sum = 0L;` 与 ` Long sum1 = 0L;` 的区别，就导致最终的一个性能消耗差了 10倍多

究其原因在于 最终给sum1赋值时，因为是包装类型，需要使用 Long.valueOf() 进行赋值，此时需要创建多个Long对象，

浪费内存也消耗了时间。

![image-20200701212529258](http://img.zhangqingdong.cn/image-20200701212529258.png)



### 4）方法变长参数

[参考链接](https://blog.csdn.net/qq_36852780/article/details/99772461)

```java
// 源码
public class Chapter01_2_4 {

    public static void main(String[] args) {
        sendMsg("deepj");
        sendMsg("deepj","hello","world");
    }
    private static void sendMsg(String msg) {
        System.out.println("sendMsg >>> " + msg);
    }
    private static void sendMsg(String... args) {

        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
// 反编译后 jad -sjava Chapter01_2_4.class
public class Chapter01_2_4 {

    public Chapter01_2_4(){}

    public static void main(String args[]) {
        sendMsg("deepj");
        sendMsg(new String[] { "deepj", "hello", "world" });
    }
    private static void sendMsg(String msg) {
        System.out.println((new StringBuilder())
                           .append(" sendMsg >>>")
                           .append(msg)
                           .toString());
    }
    private static transient void sendMsg(String args[]) {
        String as[] = args;
        int i = as.length;
        for(int j = 0; j < i; j++) {
            String arg = as[j];
            System.out.println(arg);
        }
    }
}
// sendMsg >>> deepj
// deepj
// hello
// world
```

由编译后的代码可知，变长参数，就是在编译时，将它转换为参数数组进行传递。

#### 注意点：

>  1) 变长参数的位置

![image-20200701215103173](http://img.zhangqingdong.cn/image-20200701215103173.png)

只能存放在最后一个位置，且只能出现一个可变长参数



>  2) 匹配问题

如果重载了可变参数的方法, 优先调用匹配定长参数的方法,不定参数的那个重载方法是最后被选中的。

如上例 sendMsg("deepj"); 它既能匹配定长参数，也能匹配不定长参数，此时虚拟机会优先让它匹配定长参数。



> 3) transient 关键字

 `TODO`待更新，序列化章节进行深入探讨。



### 5）枚举

> 简单使用

```java
// 源码
enum ApiStatus {
    SUCCESS,
    ERROR,
    ;
}
// 反编译 jad -sjava Chapter01_2_5.class
static final class ApiStatus extends Enum {

    public static ApiStatus[] values() {
        return (ApiStatus[])$VALUES.clone();
    }

    public static ApiStatus valueOf(String name) {
        return (ApiStatus)Enum.valueOf(com/deepj/architecture/chapter01/Chapter01_2_5$ApiStatus, name);
    }

    public static final ApiStatus SUCCESS;
    public static final ApiStatus ERROR;
    private static final ApiStatus $VALUES[];

    static {
        SUCCESS = new ApiStatus("SUCCESS", 0);
        ERROR = new ApiStatus("ERROR", 1);
        $VALUES = (new ApiStatus[] {
            SUCCESS, ERROR
        });
    }

    private ApiStatus(String s, int i) {
        super(s, i);
    }
}

```

流程

- 类默认继承了 `Enum` ，也就是说枚举类不能再继承类，但是可以实现接口
- 内部拥有一个静态的两个参数的构造方法，`String s, int i`
- 源码中定义的属性，添加了`public static final ` 修饰符进行修饰
- 定义了一个内部私有`$VALUES[]`, 用于提供一个静态公有方法`values()`获取所有枚举值的数组
- 静态代码块用于创建静态成员对象，以及给私有的`$VALUES[]`赋值
- 埋个坑 `Enum.valueOf` 的具体作用 TODO



> 常用方式

```java
enum ApiResult {
    SUCCESS("0000", "成功"),
    ERROR("0001", "失败"),
    ERROR_404("0002", "请求不存在"),
    ;
    private String code;
    private String msg;

    ApiResult(String code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    public String getCode() {
        return code;
    }
    public String getMsg() {
        return msg;
    }
}
```

就是给这个枚举类添加属性，并且在构造的时候直接加上该属性`SUCCESS("0000", "成功")`

其他需要注意的是反编译的构造方法是4个参数，再就是跟简单用法保持一致

```java
private ApiResult(String s, int i, String code, String msg) {
    super(s, i);
    this.code = code;
    this.msg = msg;
}
```



> 不常见用法 - 定义抽象类

```java
enum Operator {

    ADD("+") {
        @Override
        public int eval(int a, int b) {
            return a + b;
        }
    },
    ;
    private String code;

    Operator(String code) {
        this.code = code;
    }

    public String getCode() {
        return code;
    }
	// 定义了一个内部的抽象方法，在ADD属性中进行重写
    public abstract int eval(int x, int y);
}
// 使用方式
// int result = Operator.ADD.eval(3, 5);
// 我觉得这个可以用来替代C++里面自定义操作符的功能，内部就是通过匿名内部类实现的

// 反编译源码
static abstract class Operator extends Enum {

    public static Operator[] values() {
        return (Operator[])$VALUES.clone();
    }

    public static Operator valueOf(String name) {
        return (Operator)Enum.valueOf(com/deepj/architecture/chapter01/Chapter01_2_5$Operator, name);
    }

    public String getCode() {
        return code;
    }

    public abstract int eval(int i, int j);

    public static final Operator ADD;
    private String code;
    private static final Operator $VALUES[];

    static  {
        ADD = new Operator("ADD", 0, "+") {

            public int eval(int a, int b) {
                return a + b;
            }

        }
        ;
        $VALUES = (new Operator[] {
            ADD
        });
    }

    private Operator(String s, int i, String code) {
        super(s, i);
        this.code = code;
    }

}
```



> 不常见用法 - 继承接口

```java
enum AssertEnum implements Predicate<ApiStatus> {

    fetchResult {
        @Override
        public boolean test(ApiStatus apiStatus) {
            return apiStatus == ApiStatus.SUCCESS;
        }
    },
    ;
}

// 使用方式
// boolean test = AssertEnum.fetchResult.test(ApiStatus.SUCCESS);

// 源码中有处比较不一样的地方, 就是在还原匿名内部类的时候，它有两个test方法，一个是原生的test(Object obj)，
// 另一个就是我们定义的test(ApiStatus apiStatus)， 这是因为泛型擦除导致的一个方法重载
fetchResult = new AssertEnum("fetchResult", 0) {

    public boolean test(ApiStatus apiStatus) {
        return apiStatus == ApiStatus.SUCCESS;
    }

    public volatile boolean test(Object obj) {
        return test((ApiStatus)obj);
    }
}
```



### 6）内部类

> 为什么要使用内部类

内部类可以绕过Java单继承的限制，使一个Java类实现事实上的 继承多个类



> 非内部类

```java
package com.deepj.architecture.chapter01;

/**
 * 内部类
 *
 * @author qingdong.zhang
 * @version 1.0
 * @since 2020-6-30-22:51
 */
public class Chapter01_2_6 {
    public static void main(String[] args) {
        System.out.println("hello");
    }
}

class Chapter01_2_6_1{
    public static void main(String[] args) {
        System.out.println("world");
    }
}

// 这里，Chapter01_2_6 与 Chapter01_2_6_1 没有内部类的关系，它们仅仅表示在同一个包内，编译后是两个class文件
// 这里，两个类的关系，只能算是同包。（在同一个包下）。
// 同包特性：两个类能互相找到，不需要import导入
// 再就是Chapter01_2_6_1 默认的修饰符类型是 default，一个java源文件，最多只能有一个public修饰的class类，且只能跟java文件名相同
```

![image-20200703193001551](http://img.zhangqingdong.cn/image-20200703193001551.png)



> 静态内部类

```java
public class Chapter01_2_6 {

    private String version;

    public static void main(String[] args) {
        String version = Chapter01_2_6.Inner01.version;
    }

    // 静态内部类，与一个外部静态类无任何区别，只不过是定义在了这个类中而已，如果是公有的，在外部使用时仅需要加上嵌套类的前缀
    // 更常见用法是定义为私有的，使其仅供该类使用
    public static class Inner01 {
        public static final String version = "1.0";
    }

}

```



> 非静态内部类

```java
public class Chapter01_2_6 {

    private String version = "1.0";

    public static void main(String[] args) {
        Chapter01_2_6.Inner02 inner02 = new Chapter01_2_6().new Inner02();
        inner02.print();
    }

    // 非静态内部类
    public class Inner02 {

        private String ver = "2.0";

        public void print() {
            System.out.println(Inner02.this.ver);
            System.out.println(Chapter01_2_6.this.version);
        }
    }
}
```

this 字段的使用

```bash
Inner02.this.ver
Chapter01_2_6.this.version
```

两者的this及之前的类名都可以去掉，由编译器自动添加。



反编译之后的源码解读

`jad.exe -sjava Chapter01_2_6.class`

`jad.exe -sjava Chapter01_2_6$Inner02.class`

```java
public class Chapter01_2_6 {
    public class Inner02 {

        public void print() {
            System.out.println(ver);
            System.out.println(version);
        }

        private String ver;
        final Chapter01_2_6 this$0;

        public Inner02() {
            this.this$0 = Chapter01_2_6.this;
            super();
            ver = "2.0";
        }
    }


    public Chapter01_2_6() {
        version = "1.0";
    }

    public static void main(String args[]) {
        Inner02 inner02 = (new Chapter01_2_6()). new Inner02();
        inner02.print();
    }

    private String version;

}
```

仅查看`Chapter01_2_6.java`中查看代码区别：

```java
// Inner02 中多出了一个指向其外围类的成员属性，命名为 this$0
// 在构造器中为this$0赋值，指向了外围类
final Chapter01_2_6 this$0;

public Inner02() {
    this.this$0 = Chapter01_2_6.this;
    super();
    ver = "2.0";
}
```

再查看 `Chapter01_2_6$Inner02.java`源码，

```java
public class Chapter01_2_6$Inner02 {

    public void print() {
        System.out.println(ver);
        System.out.println(Chapter01_2_6.access$000(Chapter01_2_6.this));
    }

    private String ver;
    final Chapter01_2_6 this$0;

    public Chapter01_2_6$Inner02() {
        this.this$0 = Chapter01_2_6.this;
        super();
        ver = "2.0";
    }
}
```

很奇怪的是，在打印外围类的成员变量时，本来期待的值应该是this$0.version，但实际上打印语句变成了：

**System.out.println(Chapter01_2_6.access$000(Chapter01_2_6.this));**

多出了一个没 见过的方法 `access$000()`

在Chapter01_2_6的反编译源码中也未见到该函数，再回头看看字节码

![image-20200707001523608](http://img.zhangqingdong.cn/image-20200707001523608.png)

发现Chapter01_2_6字节码中多出了一个 `static synthetic access$000()` 函数，这个就是我们在找的方法了。也是编译器为我们做的工作，只不过好像在我们看来，有点多此一举。



回过头来，因为在Inner02 内部类中维护了一个外部类的一个引用关系，保存这份引用要消耗时间和空间，并且会导致外围实例在符合垃圾回收时却得以保留，由此可能会造成内存泄漏。而且这种BUG很难定位，因为代码不可见。



> 局部内部类

**在方法中定义的内部类称为局部内部类**

```java
public class Chapter01_2_6 {

    private String version = "1.0";

    public static void main(String[] args) {
        new Chapter01_2_6().showClass();
    }

    // 局部内部类
    public void showClass() {

        class Inner03 {
            public void print03() {
                System.out.println(Chapter01_2_6.this.version);
            }
        }
        new Inner03().print03();
    }
}
```



查看源码与成员内部类一致

```java
public class Chapter01_2_6
{

    public Chapter01_2_6()
    {
        version = "1.0";
    }

    public static void main(String args[])
    {
        (new Chapter01_2_6()).showClass();
    }

    public void showClass()
    {
        class _cls1Inner03
        {

            public void print03()
            {
                System.out.println(version);
            }
			// 保存有一个外围类的操作句柄
            final Chapter01_2_6 this$0;

            _cls1Inner03()
            {
                this.this$0 = Chapter01_2_6.this;
                super();
            }
        }

        (new _cls1Inner03()).print03();
    }

    private String version;

}
```

```java

class Chapter01_2_6$1Inner03
{

    public void print03()
    {
        // 与 成员内部类代码一致
        System.out.println(Chapter01_2_6.access$000(Chapter01_2_6.this));
    }

    final Chapter01_2_6 this$0;

    Chapter01_2_6$1Inner03()
    {
        this.this$0 = Chapter01_2_6.this;
        super();
    }
}
```



> 匿名内部类

一般是在方法内直接实现接口，因该类不作为他用，只会出现一次，也就无需再定义它的名称

```java
public class Chapter01_2_6 {

    private String version = "1.0";

    public static void main(String[] args) {
        new Chapter01_2_6().showAnonymous();
    }

    // 匿名内部类
    public void showAnonymous(){

        Predicate nullPredicate = new Predicate() {
            @Override
            public boolean test(Object o) {
                return ObjectUtils.isEmpty(o);
            }
        };
        System.out.println(nullPredicate.test(1L));
        System.out.println(nullPredicate.test("abc"));
        System.out.println(nullPredicate.test(null));
        System.out.println(nullPredicate.test(""));

    }
}
```



反编译源码 匿名内部类的源码 `Chapter01_2_6$1`

```java
class Chapter01_2_6$1
    implements Predicate
{

    public boolean test(Object o)
    {
        return ObjectUtils.isEmpty(o);
    }

    final Chapter01_2_6 this$0;

    Chapter01_2_6$1()
    {
        this.this$0 = Chapter01_2_6.this;
        super();
    }
}
```



### 7）条件编译

```java
public class Chapter01_2_7 {


    public static void main(String[] args) {
        say();
    }

    private static void say() {
        if (false) {
            System.out.println("false not show.");
        }
    }
}
```

Java编译器在看到有判断条件为永假时，会默认跳过永假代码块，保证字节码的干净。



反编译后的源码查看

```java
public class Chapter01_2_7
{

    public Chapter01_2_7()
    {
    }

    public static void main(String args[])
    {
        say();
    }

    private static void say()
    {
    }
}
```



用途： 在框架中，经常看到日志的输出判断，就是用到了条件编译，避免框架编译后的jar容量过大。

<img src="http://img.zhangqingdong.cn/image-20200707101551651.png" alt="image-20200707101551651" style="zoom: 50%;" />



### 8）断言

断言使用场景：

1）断言只适用复杂的调式过程。

2）断言一般用于程序执行结构的判断，**千万不要**让断言处理业务流程。



```java
public class Chapter01_2_8 {

    public static void main(String[] args) {
        show();
    }

    private static void show() {
        assert 3 == add(1,2);
        assert 4 == add(1,2);
    }

    private static int add(int x, int y) {
        return x + y;
    }
}
// 反编译源码


```



初看程序应该会报出异常或错误信息，但是实际执行后，什么都没有发生，经过查阅，需要开启断言配置。VM参数配置 `-ea`

![image-20200707102618768](http://img.zhangqingdong.cn/image-20200707102618768.png)

![image-20200707102707319](http://img.zhangqingdong.cn/image-20200707102707319.png)

再次执行，发现是`AssertionError` ， 错误类型，而非异常类型。

![image-20200707102746621](http://img.zhangqingdong.cn/image-20200707102746621.png)



回顾Java Error类错误示意， 表示是程序无法处理的错误，表示应用程序运行中出现了较严重问题。

这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。也就是说，当出现`AssertionError` 时，jvm就选择退出了，不再执行后续的程序。



经实际测试， 只要能够catch Error，程序也可以实际运行，但实际开发者，很少有程序员去处理Error错误，因为Error设计的目的，就是不需要程序员去处理的错误类型。



```java
public class Chapter01_2_8 {

    public static void main(String[] args) throws Exception,Error {

        try {
            show();
            throw new RuntimeException("java");
        } catch (Exception e) {
            System.out.println("into exception...");
        } catch (Error e) {
            System.out.println("into error...");
        } finally {
            System.out.println("into finally...");
        }

        ServerSocket server = new ServerSocket(8080);
        while (true) {
            System.out.println("wait connect...");
            server.accept();
        }

    }

    private static void show() {
        assert 3 == add(1,2);
        assert 4 == add(1,2);
    }

    private static int add(int x, int y) {
        return x + y;
    }
}
// into error...
// into finally...
// wait connect...
```



再就是遇见Error错误，JVM退出，是因为JVM设计中，没有catch Error的地点，下图可以编译执行，执行结果就是JVM退出执行。

![image-20200707104647486](http://img.zhangqingdong.cn/image-20200707104647486.png)



而Exception的设计初衷，就是需要程序员来处理的问题，所以在开发编译阶段，就会提示程序员去处理，避免JVM退出惨剧。

![image-20200707104826943](http://img.zhangqingdong.cn/image-20200707104826943.png)



### 9）数值字面量

```java
public class Chapter01_2_9 {

    public static void main(String[] args) {
        
        long creditCardNumber = 1234_5678_1234L;
        long socialSecurityNumber = 999_99_99_99L;
        float pi =  3.14_15F;
        long hexBytes =0xFF_EC_DE_5E;
        long hexWords =0xCAFE_BABE;
        long maxLong =0x7fff_ffff_ffff_ffffL;
        //使用b常量标识前缀表示二进制数字字面值
        byte nybbles =0b0010_0101;
        long bytes =0b1101_0010_0110_1001_1001_0100_1001_0010;       
    }
}
```

字符字面量这个语法糖真的是给开发者看的， 用来更好的展示数值信息，没有其他作用



```java
// 反编译后的源码
public class Chapter01_2_9
{

    public Chapter01_2_9()
    {
    }

    public static void main(String args[])
    {
        long creditCardNumber = 0x1cbe98fbb2L;
        long socialSecurityNumber = 0x3b9ac9ffL;
        float pi = 3.1415F;
        long hexBytes = 0xffffffffffecde5eL;
        long hexWords = 0xffffffffcafebabeL;
        long maxLong = 0x7fffffffffffffffL;
        byte nybbles = 37;
        long bytes = 0xffffffffd2699492L;
    }
}
```

### 10）for-each

```java
public class Chapter01_2_10 {

    public static void main(String[] args) {
        Integer[] arr = {1, 2, 3, 123, 5, 6, 7, 897};
        commonCycle(arr);

        System.out.println("\n====================");

        List<Integer> intArr = Arrays.asList(arr);
        iteratorCycle(intArr);

        System.out.println("\n\n=========增强型for循环===========\n");

        for (Integer ii : arr) {
            System.out.print(ii+",");
        }
        System.out.println("\n====================");
        for (Integer jj : intArr) {
            System.out.print(jj+",");
        }

    }

    // 数组循环
    private static void commonCycle(Integer[] arr) {
        for (int i = 0; i < arr.length; i++) {
            System.out.print(arr[i]+",");
        }
    }

    // 迭代器循环
    private static void iteratorCycle(Collection<Integer> collection) {

        for (Iterator<Integer> i = collection.iterator();  i.hasNext() ;) {
            Integer next = i.next();
            System.out.print(next+",");
        }
    }

}

```

![image-20200707145209019](http://img.zhangqingdong.cn/image-20200707145209019.png)



查看反编译源码，增强型for循环**底层逻辑还是使用 数组及迭代器**遍历。

> 易错点

```java
// 源代码
private static void errorWhenForEnhance() {
    List<Integer> intArr = null;
    for (Integer ii : intArr) {
        System.out.println(ii);
    }
}
// 反编译
private static void errorWhenForEnhance() {
    List<Integer> intArr = null;
    Iterator var1 = ((List)intArr).iterator();

    while(var1.hasNext()) {
        Integer ii = (Integer)var1.next();
        System.out.println(ii);
    }
}
```

因为intArr 为null， 进行`((List)intArr).iterator()`时会出现空指针，此时编译阶段是不能排查出问题的，所以需要关注。



> 自定义for循环对象

```java
class PrintPI implements Iterable<Character>{

    public final String PIStr = String.valueOf(Math.PI);
    public int cur = 0;
    public int len = PIStr.length();

    @Override
    public Iterator<Character> iterator() {

        return new Iterator<Character>() {
            @Override
            public boolean hasNext() {
                return cur < len;
            }

            @Override
            public Character next() {
                return PIStr.charAt(cur++);
            }
        };
    }
}
```

```java
public static void main(String[] args) {

    PrintPI printPI = new PrintPI();
   
    for (char x : printPI) {
        System.out.print(x);
    }
}
// 3.141592653589793
```

只要对象实现了`Iterable`接口， 该对象就可以使用增强型for循环进行遍历



### 11）try-with-resource

```java
public class Chapter01_2_11 {

    public static void main(String[] args) throws Exception {

        copy("d:/tmp.txt", "d:/tmp1.txt");

    }

    private static void copy(String src, String dst) throws IOException {
        InputStream in = new FileInputStream(src);
        try {
            OutputStream out = new FileOutputStream(dst);
            try {
                byte[] buf = new byte[1024];
                int n;
                while ((n = in.read(buf)) >= 0) {
                    out.write(buf, 0, n);
                }
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }
    }
}
```

默认把资源关闭放在finally块中，避免资源不关闭导致的问题。



```java
// 把资源放在try() 语句中，会自动关闭，前提条件：资源实现了Closeable接口
private static void newCopy(String src, String dst) throws IOException {

    try(InputStream in = new FileInputStream(src);
        OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[1024];
        int n;
        while ((n = in.read(buf)) >= 0) {
            out.write(buf, 0, n);
        }
    }
}
```



`private static void copy(String src, String dst)` 方法是新手经常写的代码，这里存在的问题：

1. catch 语句不存在，导致出现问题向上抛
2. out.close(); 方法也可能出错，当out被关闭时，此时对象为null，再调用close就会报空指针

而`private static void newCopy(String src, String dst)`就帮我们做了以上两点，可以查看反编译后的代码

```java
public class Chapter01_2_11 {
    public Chapter01_2_11() {
    }

    public static void main(String[] args) throws Exception {
        copy("d:/tmp.txt", "d:/tmp1.txt");
        copy("d:/tmp.txt", "d:/tmp2.txt");
    }

    private static void copy(String src, String dst) throws IOException {
        FileInputStream in = new FileInputStream(src);

        try {
            FileOutputStream out = new FileOutputStream(dst);

            try {
                byte[] buf = new byte[1024];

                int n;
                while((n = in.read(buf)) >= 0) {
                    out.write(buf, 0, n);
                }
            } finally {
                out.close();
            }
        } finally {
            in.close();
        }

    }

    private static void newCopy(String src, String dst) throws IOException {
        InputStream in = new FileInputStream(src);
        Throwable var3 = null;

        try {
            OutputStream out = new FileOutputStream(dst);
            Throwable var5 = null;

            try {
                byte[] buf = new byte[1024];

                int n;
                while((n = in.read(buf)) >= 0) {
                    out.write(buf, 0, n);
                }
            } catch (Throwable var29) {
                var5 = var29;
                throw var29;
            } finally {
                if (out != null) {
                    if (var5 != null) {
                        try {
                            out.close();
                        } catch (Throwable var28) {
                            var5.addSuppressed(var28);
                        }
                    } else {
                        out.close();
                    }
                }
            }
        } catch (Throwable var31) {
            var3 = var31;
            throw var31;
        } finally {
            if (in != null) {
                if (var3 != null) {
                    try {
                        in.close();
                    } catch (Throwable var27) {
                        var3.addSuppressed(var27);
                    }
                } else {
                    in.close();
                }
            }
        }
    }
}

```

能够比对出来，close方法的正确关闭

```java
if (out != null) {
    if (var5 != null) {
        try {
            out.close();
        } catch (Throwable var28) {
            var5.addSuppressed(var28);
        }
    } else {
        out.close();
    }
}
```



所以，建议就是关闭资源时，使用try-resource 块，自己实现的资源类，可以实现`Closeable`，然后使用try-resource帮助自动关闭资源。



### 12）Lambda表达式

另开一个章节进行陈述。









> 其他

> javac -encoding UTF-8 Chapter01_2_6.java



