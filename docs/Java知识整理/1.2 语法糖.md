## 二、语法糖及其实现

https://blog.csdn.net/u013452337/article/details/90171881

### 1）switch 支持 String 与枚举

> [菜鸟教程switch-case讲解](https://www.runoob.com/java/java-switch-case.html)

switch case 语句有如下规则：

- switch 语句中的变量类型可以是： byte、short、int 或者 char。从 Java SE 7 开始，switch 支持字符串 String 类型了，同时 case 标签必须为字符串常量或字面量。

  ```text
  纠正：变量类型可以时char,byte,short,int 以及对应的包装类型Character/Byte/Short/Integer，还有String类型以及枚举类型
  ```

  ![image-20200623220750179](http://img.zhangqingdong.cn/image-20200623220750179.png)

- switch 语句可以拥有多个 case 语句。每个 case 后面跟一个要比较的值和冒号。

- case 语句中的值的数据类型必须与变量的数据类型相同，而且只能是常量或者字面常量。

  ```text
  纠正：当switch语句中的值为数值类型时，case值可以为范围比它小的数值类型，例如，如果是switch(int) ,case的值可以为任意的char,byte,short类型的值。
  ```

- 当变量的值与 case 语句的值相等时，那么 case 语句之后的语句开始执行，直到 break 语句出现才会跳出 switch 语句。

- 当遇到 break 语句时，switch 语句终止。程序跳转到 switch 语句后面的语句执行。case 语句不必须要包含 break 语句。如果没有 break 语句出现，程序会继续执行下一条 case 语句，直到出现 break 语句。

- switch 语句可以包含一个 default 分支，该分支一般是 switch 语句的最后一个分支（可以在任何位置，但建议在最后一个）。default 在没有 case 语句的值和变量值相等的时候执行。default 分支不需要 break 语句。

> 总结

Switch-case 支持三种入参类型：

```java
package com.deepj.architecture.chapter01;

/**
 * Java基础；语法糖及其实现机制
 *
 * @author qingdong.zhang
 * @version 1.0
 * @since 2020-6-22-22:05
 */
public class Chapter0121 {
	// 3）字符串类型
    public static String switchStrCase(String name) {

        String personDeclaration;
        switch (name) {
            case "job":
                personDeclaration = "I'm job, I'm a student.";
                break;
            case "mic":
                personDeclaration = "I'm mic, I work for APPLE.";
                break;
            case "rues":
                personDeclaration = "I'm rues, I was a football player.";
                break;
            default:
                personDeclaration = "Hi, welcome to deepj's tutorial blog. ";
        }
        return personDeclaration;
    }
	// 2）枚举类型
    public static String switchEnumCase(LangEnum lang) {

        String lanLabel;
        switch (lang) {
            case JAVA:
                lanLabel = "Java is simple.";
                break;
            case PHP:
                lanLabel = "PHP is the best.";
                break;
            case PYTHON:
                lanLabel = "Life is short you need python.";
                break;
            default:
                lanLabel = "Talk is cheap, show me the code.";
        }
        return lanLabel;
    }

    // 1）数值类型
    public static String switchIntCase(int x) {
        String caseWhen;
        switch (x) {
            case 'A':
                caseWhen = "char case in int switch.";
                break;
            case (byte) 127:
                caseWhen = "byte case in int switch.";
                break;
            case (short) 32767:
                caseWhen = "short case in int switch.";
                break;
            case 0x7fffffff:
                caseWhen = "int case in int switch.";
                break;
            default:
                caseWhen = "deepj's. int case default.";
        }
        return caseWhen;
    }
    public static void main(String[] args) {

        System.out.println(LangEnum.JAVA.ordinal());
        System.out.println(switchEnumCase(LangEnum.JAVA));
        System.out.println(Arrays.toString(LangEnum.values()));
    }
}

enum LangEnum {

    JAVA,
    PYTHON,
    CPP,
    GO,
    PERL,
    PHP;
}

```

反编译后代码

```java
// Decompiled by Jad v1.5.8g. Copyright 2001 Pavel Kouznetsov.
// Jad home page: http://www.kpdus.com/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   Chapter0121.java

package com.deepj.architecture.chapter01;

import com.deepj.architecture.common.LangEnum;
import java.io.PrintStream;
import java.util.Arrays;

public class Chapter0121
{

    public Chapter0121()
    {
    }

    public static String switchStrCase(String name)
    {
        String s = name;
        byte byte0 = -1;
        switch(s.hashCode())
        {
        case 105405: 
            if(s.equals("job"))
                byte0 = 0;
            break;

        case 108103: 
            if(s.equals("mic"))
                byte0 = 1;
            break;

        case 3511857: 
            if(s.equals("rues"))
                byte0 = 2;
            break;
        }
        String personDeclaration;
        switch(byte0)
        {
        case 0: // '\0'
            personDeclaration = "I'm job, I'm a student.";
            break;

        case 1: // '\001'
            personDeclaration = "I'm mic, I work for APPLE.";
            break;

        case 2: // '\002'
            personDeclaration = "I'm rues, I was a football player.";
            break;

        default:
            personDeclaration = "Hi, welcome to deepj's tutorial blog. ";
            break;
        }
        return personDeclaration;
    }

    public static String switchEnumCase(LangEnum lang)
    {
        static class _cls1
        {

            static final int $SwitchMap$com$deepj$architecture$common$LangEnum[];

            static 
            {
                $SwitchMap$com$deepj$architecture$common$LangEnum = new int[LangEnum.values().length];
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.JAVA.ordinal()] = 1;
                }
                catch(NoSuchFieldError nosuchfielderror) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PHP.ordinal()] = 2;
                }
                catch(NoSuchFieldError nosuchfielderror1) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PYTHON.ordinal()] = 3;
                }
                catch(NoSuchFieldError nosuchfielderror2) { }
            }
        }

        String lanLabel;
        switch(_cls1..SwitchMap.com.deepj.architecture.common.LangEnum[lang.ordinal()])
        {
        case 1: // '\001'
            lanLabel = "Java is simple.";
            break;

        case 2: // '\002'
            lanLabel = "PHP is the best.";
            break;

        case 3: // '\003'
            lanLabel = "Life is short you need python.";
            break;

        default:
            lanLabel = "Talk is cheap, show me the code.";
            break;
        }
        return lanLabel;
    }

    public static String switchIntCase(int x)
    {
        String caseWhen;
        switch(x)
        {
        case 65: // 'A'
            caseWhen = "char case in int switch.";
            break;

        case 127: // '\177'
            caseWhen = "byte case in int switch.";
            break;

        case 32767: 
            caseWhen = "short case in int switch.";
            break;

        case 2147483647: 
            caseWhen = "int case in int switch.";
            break;

        default:
            caseWhen = "deepj's. int case default.";
            break;
        }
        return caseWhen;
    }
    public static void main(String[] args) {
        System.out.println(LangEnum.JAVA.ordinal());
        System.out.println(switchEnumCase(LangEnum.JAVA));
        System.out.println(Arrays.toString(LangEnum.values()));
    }
}

```



#### Ⅰ）数值类型

数值类型能够看出最底层都转化为int类型的数值，进行比对，这样也就可以解释switch(int) case中的值可以是byte,short

#### Ⅱ）字符串类型

字符串类型可以看出是进行了两次switch比较，

第一层先使用string类型的hashcode作为switch(int) 值，case使用hashcode值，如果比较相等，再使用string类型的equals确定值相等

第二层使用第一层比较的结果来作为switch的入参。

#### Ⅲ）枚举类型

```java
static class _cls1
        {

            static final int $SwitchMap$com$deepj$architecture$common$LangEnum[];

            static 
            {
                $SwitchMap$com$deepj$architecture$common$LangEnum = new int[LangEnum.values().length];
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.JAVA.ordinal()] = 1;
                }
                catch(NoSuchFieldError nosuchfielderror) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PHP.ordinal()] = 2;
                }
                catch(NoSuchFieldError nosuchfielderror1) { }
                try
                {
                    $SwitchMap$com$deepj$architecture$common$LangEnum[LangEnum.PYTHON.ordinal()] = 3;
                }
                catch(NoSuchFieldError nosuchfielderror2) { }
            }
        }
```

枚举类型比较复杂，先是使用了一个静态内部类，在内部维护了数组对象，，该数组对象是枚举值的序数映射。

可以把$SwitchMap$com$deepj$architecture$common$LangEnum 变量名称 替换为 enumArr ，就会简明许多。

```java
尝试破坏该数组对象：使其返回错误对象，比如我输入Java，它却告诉我PHP对应的输出，
主要思路：只要破坏了这个数组对象的值，就会可能产生问题

1） LangEnum 是两个文件，编译和调用的是不一样的类对象， 
思路错误：两个文件，在调用时就会提示需要使用编译的那个类对象

2） LangEnum 是一个类，先编译一次 LangEnum.java 和 Chapter0121.java ，Chapter0121中的main方法会使用LangEnum.JAVA.origin值，之后改动LangEnum.java 中JAVA的顺序，再单独编译LangEnum.java 
思路错误：静态内部类每次在重启时后，在调用时，会重新启动，所以每次重新进行main方法的运行，都相当于重新加载了LangEnum文件
System.out.println(LangEnum.JAVA.ordinal());
System.out.println(switchEnumCase(LangEnum.JAVA));
System.out.println(Arrays.toString(LangEnum.values()));

3） 在2）的基础上，改造一下，仅调用main一次，然后静态内部类也就初始化一次，然后我再修改LangEnum后，把该文件进行重新编译，
    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()) {
            String s = sc.nextLine();
            System.out.println(LangEnum.JAVA.ordinal());
            System.out.println(switchEnumCase(LangEnum.JAVA));
            System.out.println(Arrays.toString(LangEnum.values()));
        }
    }
出现问题：1:14	Hot Swap failed.
		Chapter0121: schema change not implemented
		Chapter0121: Operation not supported by VM
		每次在不重启重新编译LangEnum的时候，告知不能单独编译这样一个文件，
		查找原因说是jvm hotswap的限制，解释说它只允许修改方法体，不能有方法或属性的添加和删除。
		我们这里修改了LangEnum的顺序，其实也就对枚举类中public static final 修饰的属性进行更改了，所以虚拟机不允许我们进行修改了，
        
综上结论：
	枚举类的switch case 是安全的，不会出现多文件,或者认为修改枚举然后未编译代码，导致出现的逻辑错误问题。
```





### 2）泛型

[泛型就这么简单](https://segmentfault.com/a/1190000014120746)

#### Ⅰ）泛型做了什么

**把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型**

#### Ⅱ）为什么需要泛型

> 设想没有泛型会发生什么？

```java
class Chapter01_2_2_Test {

    @Test
    public void generic_without() {

        Map map = new HashMap();
        map.put("cat1", new Cat("Cat1"));
        map.put("cat2", new Cat("Cat2"));
        map.put("cat3", new Cat("Cat3"));
        map.put("cat4", new Dog("Dog1"));

        for (int i = 0; i < map.size(); i++) {
            Cat cat = (Cat) map.get("cat" + (i + 1));
            System.out.println(cat.getName());
        }
    }

}
```

在对象取用时，需要强行转换为需要的对象类型，如果存在其他类型，会导致出现`ClassCastException`

```java
for (int i = 0; i < map.size(); i++) {
    Object o = map.get("cat" + (i + 1));
    if (o instanceof Cat) {
        Cat cat = (Cat) o;
        System.out.println(cat.getName());
    } else if (o instanceof Dog) {
        Dog dog = (Dog) o;
        System.out.println("忽略DOG的参数"+dog.getName());
    }
}
```

可以在取用对象值的时候， 先经过 instanceof 判断实际类型，再进行强制转换，这样可以避免运行时代码出现错误。

但是这样每次新增一种类型之后，调用的地方就需要进行适配处理，拓展性太差。

#### Ⅲ）使用泛型的好处

- 代码更加简洁【不用强制转换】
- 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
- 可读性和稳定性【在编写集合的时候，就限定了类型】

#### Ⅳ）泛型使用

##### 4.1 泛型类

```java
// 常用于定义通用报文请求/返回，把请求/返回特有的数据放在data中传输，通用属性提取出来使用
@Data
class ApiResult<T> {

    private String code;
    private String msg;
    private T data;
}
```

##### 4.2 泛型方法

```java
public class BaseRequest {
    private String seqNo;
}
public class BaseResponse {
    private String code;
    private String msg;
}

// 泛型方法常用的地点：
// 1. 不明确当前需要传递什么值，但有一种统一的处理逻辑， 使用<T> 
// 2. 需要了解T内部的一些公用字段，需要限定T的上界，用于逻辑处理
class restClient {
    public <T> void send(T req) {
        System.out.println(req.toString());
    }
    public <T extends BaseRequest, R extends BaseResponse> R sendReq(T req, Class<R> clz) {
        System.out.println(req.getSeqNo());
        // restTemplate 请求获取结果，可以直接与restTemplate结合取得对象结果
        // 或者通过获取string 对象,经过Json转化得到实体对象
        R response = null;
//        HttpEntity<String> entity = new HttpEntity<>(req);
//        response = restTemplate.postForObject(url, entity, clz);
        return response;
    }
}
```

##### 4.3 泛型类派生

```java
interface Api<T>{
    Api<T> success(T t);
    Api<T> error(T t);
}
// 子类明确泛型类的类型参数变量
class CommonApi implements Api<String>{

    String code;
    public CommonApi(String code){
        this.code = code;
    }
    @Override
    public Api<String> success(String s) {
        return new CommonApi("SUCCESS="+s);

    }
    @Override
    public Api<String> error(String s) {
        return new CommonApi("ERROR="+s);
    }
}
// 子类不明确泛型类的类型参数变量，需要在使用时明确泛型类的具体对象
class AbstractApi<T> implements Api<T> {

    @Override
    public Api<T> success(T t) {
        return null;
    }

    @Override
    public Api<T> error(T t) {
        return null;
    }
}
```

##### 4.4 泛型通配符

```java
class CommonCharacter{
    // Raw use of parameterized class 'List'  不够优雅
    public void test0(List list){
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    // 使用通配符来适配所有的List参数对象，默认? 继承自 Object
    public void test1(List<?> list){
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }
    // 当List内容上限已知时，可以限定该上限
    public void test2(List<? extends Number> list) {
        for (int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i).intValue());
        }
    }
    // 有上限就会有下限，下限使用场景：<? super Type> 传递进来的只能是Type或Type的父类
    // 使用场景较少，暂时能想到的只有 Comparator ，当某个对象需要组合其他对象的功能时，可能需要实现
    public void test3(Comparator<? super TreeSet<?>> comparator) {
    }
}

```

```shell
在泛型的上限和下限中有一个原则：PECS(Producer Extends Consumer Super)

带有子类限定的可以从泛型读取【也就是--->(? extend T)】-------->Producer Extends
带有超类限定的可以从泛型写入【也就是--->(? super T)】-------->Consumer Super

```



#### V) 泛型擦除

泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。

也就是在实际的字节码文件中，泛型信息已经全部被擦除了。

进行反编译验证：`jad -sjava CommonCharacter.class`

```java
class CommonCharacter {

    CommonCharacter() {
    }
    public void test0(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));
    }
    public void test1(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(list.get(i));
    }
    public void test2(List list) {
        for(int i = 0; i < list.size(); i++)
            System.out.println(((Number)list.get(i)).intValue());
    }
    public void test3(Comparator comparator1) {
    }
}
```

可以明显看出泛型参数类型已经被去除掉。



### 3）自动拆装箱

#### Ⅰ）什么是自动拆装箱

| 8大基本类型 | 包装类型  | 缓存值     | 缓存重定义                          |
| ----------- | --------- | ---------- | ----------------------------------- |
| byte        | Byte      | [-128,127] | 无                                  |
| char        | Character | [0,127]    | 无                                  |
| short       | Short     | [-128,127] | 无                                  |
| int         | Integer   | [-128,127] | java.lang.Integer.IntegerCache.high |
| long        | Long      | [-128,127] | 无                                  |
| float       | Float     | 无         | 无                                  |
| double      | Double    | 无         | 无                                  |
| boolean     | Boolean   | 无         | 无                                  |

> 概念解析

Java 系统内由 基本类型转换为包装类型，称为装箱，相反由包装类转化为基本类型的称为拆箱，因为这些动作不需要开发人员参与，所以叫做自动拆装箱。

> 使用场景

```java
// 源码
public static void main(String[] args) {
    Integer i = 10;
    int j = i;
}
// 反编译代码 jad -sjava Chapter01_2_3.class
public static void main(String args[]){
    Integer i = Integer.valueOf(10);
    int j = i.intValue();
}
```

`Integer i = 10;`

当把基本类型值直接赋值给包装类型时，这个过程就会产生自动装箱

`int j = i;`

当把包装类型i直接赋值给基本类型时，会产生自动拆箱的动作。



其他基本类型与包装类型的自动拆装箱与此类似。

![image-20200701115802363](http://img.zhangqingdong.cn/image-20200701115802363.png)

Byte/Short/Integer/Long/Float/Double 都继承自`Number` ,所以都可以转换成这六类对象的基本类型。

![image-20200701143132503](http://img.zhangqingdong.cn/image-20200701143132503.png)

#### Ⅱ） 有什么用

1. 可以直接给包装类型赋值，不需要显示转换
2. 包装类与基本类型可以混用，无需进行强制转换

#### Ⅲ）踩坑指南

> 包装类缓存

```java
private static void testEqual() {
    Integer a = 127;
    Integer b = 127;
    System.out.println("a == b => " + (a == b));

    Integer x = 128;
    Integer y = 128;
    System.out.println("x == y => " + (x == y));
}

// ======== output =========
// a == b => true
// x == y => false
```

如果不知道自动装箱机制，这里就会感觉莫名其妙，明明一样的处理，为什么，一个127 是true，128就是false。

但经过上面的装箱机制，我们知道 `Integer x = 128;` 转化成了 `Integer x = Integer.valueOf(128);`

现在看下`Integer.valueOf() `方法源码：

```java
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

这里经过了一个比较， 如果 `int i `的值在`IntegerCache.low`和`IntegerCache.high`的区间内，就拿`IntegerCache.cache `中的缓存来赋值。

这个缓存的值在 **什么是自动拆装箱** 表中已经展示了出来，区间为[-128,127] ，且这个值可以配置。配置项为`java.lang.Integer.IntegerCache.high`



> 空指针

```java
private static void testNullPoint(){
    Integer a = 10;
    // ==== 经过各种业务操作 start ====
    a = null;
    // ==== 经过各种业务操作 end ====
    int b = a;
}

// com.deepj.architecture.chapter01.Chapter01_2_3
// Exception in thread "main" java.lang.NullPointerException
// 		at com.deepj.architecture.chapter01.Chapter01_2_3.testNullPoint(Chapter01_2_3.java:48)
// 		at com.deepj.architecture.chapter01.Chapter01_2_3.main(Chapter01_2_3.java:15)
```

同理，在`int b = a;` 该行抛出一个空指针，如果不知道自动拆箱机制，也会导致开发人员一脸生无可恋。

此时知道有拆箱机制，看下具体原因 `int b = a.intValue();`此时`a`为null， 也就显而易见报了空指针



> 基本类型与包装类型的混合操作

```java
// 源码
private static void testEquals() {
    int a = 128;
    Integer b = 128;
    System.out.println("1>>> " + (a == b));
    System.out.println("2>>> " + b.equals(a));

    System.out.println("3>>> " + b.equals(127 + 1));
    System.out.println("4>>> " + b.equals(127L + 1));
}
// 反编译 jad -sjava Chapter01_2_3.class
private static void testEquals(){
    int a = 128;
    Integer b = Integer.valueOf(128);
    System.out.println((new StringBuilder()).append("1>>> ")
                       .append(a == b.intValue()).toString());
    System.out.println((new StringBuilder()).append("2>>> ")
                       .append(b.equals(Integer.valueOf(a))).toString());
    System.out.println((new StringBuilder()).append("3>>> ")
                       .append(b.equals(Integer.valueOf(128))).toString());
    System.out.println((new StringBuilder()).append("4>>> ")
                       .append(b.equals(Long.valueOf(128L))).toString());
}

// =========== output =================
// 1>>> true
// 2>>> true
// 3>>> true
// 4>>> false
```

+ **当一个基础数据类型与封装类进行==、+、-、*、/运算时，会将封装类进行拆箱，对基础数据类型进行运算。**
+ **当基础数据类型与包装类型进行 equals 比较时，所传入的参数类型是原始数据类型时，会自动对其装箱，** 且相关equals方法被重写为 `obj instanceof Integer && value == ((Integer)obj).intValue()`



> 无意识装箱性能消耗

```java
private static void testPerformance() {
    long time1 = System.currentTimeMillis();
    long sum = 0L;
    for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
        sum += i;
    }
    System.out.println(sum);
    System.out.println(System.currentTimeMillis() - time1);

    System.out.println("==========================================");

    long time2 = System.currentTimeMillis();
    Long sum1 = 0L;
    for (int i = 0; i < Integer.MAX_VALUE / 2; i++) {
        sum1 += i;
    }
    System.out.println(sum);
    System.out.println(System.currentTimeMillis() - time2);
}

// =================== output =======================

// 576460750692810753
// 288
// ==========================================
// 576460750692810753
// 3065

```

仅仅是定义 `long sum = 0L;` 与 ` Long sum1 = 0L;` 的区别，就导致最终的一个性能消耗差了 10倍多

究其原因在于 最终给sum1赋值时，因为是包装类型，需要使用 Long.valueOf() 进行赋值，此时需要创建多个Long对象，

浪费内存也消耗了时间。

![image-20200701212529258](http://img.zhangqingdong.cn/image-20200701212529258.png)



### 4）方法变长参数

[参考链接](https://blog.csdn.net/qq_36852780/article/details/99772461)

```java
// 源码
public class Chapter01_2_4 {

    public static void main(String[] args) {
        sendMsg("deepj");
        sendMsg("deepj","hello","world");
    }
    private static void sendMsg(String msg) {
        System.out.println("sendMsg >>> " + msg);
    }
    private static void sendMsg(String... args) {

        for (String arg : args) {
            System.out.println(arg);
        }
    }
}
// 反编译后 jad -sjava Chapter01_2_4.class
public class Chapter01_2_4 {

    public Chapter01_2_4(){}

    public static void main(String args[]) {
        sendMsg("deepj");
        sendMsg(new String[] { "deepj", "hello", "world" });
    }
    private static void sendMsg(String msg) {
        System.out.println((new StringBuilder())
                           .append(" sendMsg >>>")
                           .append(msg)
                           .toString());
    }
    private static transient void sendMsg(String args[]) {
        String as[] = args;
        int i = as.length;
        for(int j = 0; j < i; j++) {
            String arg = as[j];
            System.out.println(arg);
        }
    }
}
// sendMsg >>> deepj
// deepj
// hello
// world
```

由编译后的代码可知，变长参数，就是在编译时，将它转换为参数数组进行传递。

#### 注意点：

>  1) 变长参数的位置

![image-20200701215103173](http://img.zhangqingdong.cn/image-20200701215103173.png)

只能存放在最后一个位置，且只能出现一个可变长参数



>  2) 匹配问题

如果重载了可变参数的方法, 优先调用匹配定长参数的方法,不定参数的那个重载方法是最后被选中的。

如上例 sendMsg("deepj"); 它既能匹配定长参数，也能匹配不定长参数，此时虚拟机会优先让它匹配定长参数。



> 3) transient 关键字







### 5）枚举

### 6）内部类

### 7）条件编译

### 8）断言

### 9）数值字面量

### 10）for-each

### 11）try-with-resource

### 12）Lambda表达式















